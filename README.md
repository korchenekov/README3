## Анализ алгоритма: Сортировка выбором (Selection Sort)
*   **Определение:**
    *   Selection Sort — это алгоритм, который разделяет массив на две части: отсортированную и неотсортированную. На каждом шаге он находит минимальный элемент в неотсортированной части и меняет его местами с первым элементом этой части.
*   **Анализ:**
    *   Алгоритм находит минимальный элемент в неотсортированной части массива и обменивает его с первым элементом неотсортированной части.
    *   Внешний цикл `for` выполняется `n-1` раз.
    *   Внутренний цикл `for` в худшем случае выполняется `n-1`, затем `n-2`, ... раз за каждый проход внешнего цикла.
    *   Общее количество сравнений примерно равно `n*(n-1)/2`.
*   **Временная сложность: O(n²)**
*   **Обоснование O(n²):** Два вложенных цикла, где каждый из них в среднем или худшем случае зависит от `n`. Внутренний цикл может выполняться до `n` раз для каждого из `n` итераций внешнего цикла, что приводит к квадратичной зависимости.

---

## Анализ алгоритма: Сортировка обменом (Bubble Sort)
*   **Определение:**
    *   Bubble Sort — это простой алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они расположены в неправильном порядке.
*   **Анализ:**
    *   Алгоритм проходит по массиву, сравнивая соседние элементы и меняя их местами, если левый больше правого, обеспечивая "всплытие" наибольшего элемента.
    *   Внешний цикл `for` выполняется `n-1` раз.
    *   Внутренний цикл `for` в худшем случае выполняется `n-1`, затем `n-2`, ... раз.
    *   Оптимизация с флагом `swapped` позволяет завершить выполнение досрочно, если массив уже отсортирован.
*   **Временная сложность:**
    *   **Худший случай: O(n²)** — массив отсортирован в обратном порядке
    *   **Лучший случай: O(n)** — массив уже отсортирован
    *   **Средний случай: O(n²)**
*   **Обоснование O(n²):** В худшем случае требует примерно `n*(n-1)/2` сравнений и потенциальных обменов.

---

## Анализ алгоритма: Сортировка вставками (Insertion Sort)
*   **Определение:**
    *   Insertion Sort — это алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый элемент размещается в подходящее место среди ранее упорядоченных элементов.
*   **Анализ:**
    *   Алгоритм строит отсортированную часть списка, начиная с первого элемента. Каждый новый элемент вставляется в правильную позицию среди уже отсортированных.
    *   Внешний цикл `for` проходит по `n-1` элементам.
    *   Внутренний цикл `while` в худшем случае может выполнить до `i` итераций на `i`-ой итерации внешнего цикла.
*   **Временная сложность:**
    *   **Худший случай: O(n²)** — массив отсортирован в обратном порядке
    *   **Лучший случай: O(n)** — массив уже отсортирован
    *   **Средний случай: O(n²)**
*   **Обоснование O(n²):** В худшем случае общее количество сдвигов и сравнений составляет `n*(n-1)/2`.

---

## Анализ алгоритма: Сортировка слиянием (Merge Sort)
*   **Определение:**
    *   Merge Sort — алгоритм сортировки, который упорядочивает списки в определённом порядке, используя стратегию "разделяй и властвуй".
*   **Анализ:**
    *   Алгоритм рекурсивно делит массив пополам до подмассивов размером 1.
    *   Затем сливает эти подмассивы, создавая большие отсортированные подмассивы.
    *   Функция `merge` объединяет два отсортированных подмассива.
*   **Временная сложность: O(n log n)**
*   **Обоснование O(n log n):**
    *   **Глубина рекурсии:** `log n` уровней
    *   **Работа на уровне:** На каждом уровне выполняется слияние `n` элементов
    *   **Общая сложность:** `log n` уровней × `n` операций на уровне = `O(n log n)`

---

## Анализ алгоритма: Сортировка Шелла (Shell Sort)
*   **Определение:**
    *   Shell Sort — это усовершенствованный вариант сортировки вставками, который сравнивает элементы на определённом расстоянии друг от друга.
*   **Анализ:**
    *   Модификация сортировки вставками, сначала сортирующая элементы на определённом расстоянии (gap).
    *   Выбор последовательности gap влияет на производительность.
*   **Временная сложность:**
    *   Зависит от выбранной последовательности gaps
    *   Для последовательности `n/2^k`: **O(n^(3/2))** или **O(n log² n)**
    *   В худшем случае: **O(n²)**
    *   Для последовательности Кнута: **O(n^(3/2))**
*   **Обоснование:** Сложность зависит от gap-последовательности и обычно находится между `O(n)` и `O(n²)`.

---

## Анализ алгоритма: Быстрая сортировка (Quick Sort)
*   **Определение:**
    *   Quick Sort — эффективный алгоритм сортировки, использующий принцип «разделяй и властвуй».
*   **Анализ:**
    *   Выбирается опорный элемент, массив перераспределяется относительно него.
    *   Рекурсивно сортируются левая и правая части.
    *   Выбор опорного элемента критичен для производительности.
*   **Временная сложность:**
    *   **Средний случай: O(n log n)**
    *   **Худший случай: O(n²)**
    *   **Лучший случай: O(n log n)**
*   **Обоснование:**
    *   **Средний/Лучший:** Глубина рекурсии `log n`, на каждом уровне `n` операций
    *   **Худший:** Глубина рекурсии `n`, на каждом уровне до `n` операций

---

## Анализ алгоритма: Пирамидальная сортировка (Heap Sort)
*   **Определение:**
    *   Heap Sort — алгоритм сортировки сравнением, использующий структуру данных "двоичная куча".
*   **Анализ:**
    *   Сначала строится max-heap.
    *   Максимальный элемент извлекается и помещается в конец массива.
    *   Свойство heap восстанавливается для оставшейся части.
*   **Временная сложность: O(n log n)**
*   **Обоснование O(n log n):**
    *   **Построение кучи:** O(n)
    *   **Сортировка:** `n` вызовов `heapify` по O(log n) каждый
    *   **Общая сложность:** O(n) + O(n log n) = O(n log n)

---

## Анализ алгоритма: Линейный поиск (Linear Search)
*   **Определение:**
    *   Linear Search — простой алгоритм, который последовательно проверяет каждый элемент в наборе данных.
*   **Анализ:**
    *   Алгоритм последовательно просматривает элементы массива, сравнивая их с искомым значением.
*   **Временная сложность:**
    *   **Худший случай: O(n)**
    *   **Лучший случай: O(1)**
    *   **Средний случай: O(n)**
*   **Обоснование O(n):** В худшем случае нужно проверить все `n` элементов.

---

## Анализ алгоритма: Бинарный поиск (Binary Search)
*   **Определение:**
    *   Binary Search — алгоритм для поиска элемента в отсортированном массиве.
*   **Анализ:**
    *   Алгоритм работает только с отсортированным массивом.
    *   На каждом шаге область поиска уменьшается вдвое.
*   **Временная сложность: O(log n)**
*   **Обоснование O(log n):** Количество шагов для сокращения `n` до 1 равно `log₂ n`.

---

## Анализ алгоритма: Интерполяционный поиск (Interpolation Search)
*   **Определение:**
    *   Interpolation Search — алгоритм поиска в упорядоченном массиве, работающий быстрее бинарного поиска при равномерном распределении данных.
*   **Анализ:**
    *   Похож на бинарный поиск, но предполагает позицию элемента на основе его значения.
*   **Временная сложность:**
    *   **Средний случай: O(log log n)**
    *   **Худший случай: O(n)**
*   **Обоснование:**
    *   **Средний:** При равномерном распределении размер области поиска уменьшается быстрее
    *   **Худший:** При неравномерном распределении может деградировать до линейного поиска

---

## Анализ алгоритма: Поиск Фибоначчи (Fibonacci Search)
*   **Определение:**
    *   Fibonacci Search — алгоритм для поиска в отсортированном массиве, использующий числа Фибоначчи.
*   **Анализ:**
    *   Использует числа Фибоначчи для определения точек разбиения массива.
*   **Временная сложность: O(log n)**
*   **Обоснование O(log n):** Количество итераций пропорционально `log n`.
