## Вычислительная характеристика метода последовательного выбора

**Фундаментальные принципы:**
- Стратегия обработки предполагает последовательное выделение минимальных элементов из неупорядоченного сегмента с их последующим размещением в конечной позиции обработанной зоны

**Особенности вычислительного процесса:**
- Внешний итерационный блок выполняет n-1 проходов
- Внутренний цикл сравнений уменьшается от n-1 до 1 операции
- Суммарная вычислительная нагрузка оценивается как квадратичная функция от n

**Асимптотическая оценка: O(n²)**
- Обоснование: Двухуровневая итерационная структура с линейной зависимостью на каждом уровне создает n*(n-1)/2 операций сравнения

---



## Вычислительная характеристика метода попарного обмена

**Фундаментальные принципы:**
- Стратегия последовательного сравнения и обмена смежных элементов массива
- Многократные проходы по данным до достижения полной упорядоченности

**Особенности вычислительного процесса:**
- Внешний циклический блок выполняет (n-1) полных проходов по массиву
- Внутренний цикл осуществляет (n-i-1) операций сравнения на i-й итерации
- Механизм отслеживания обменов позволяет досрочно завершать обработку

**Детальный анализ циклов:**
- Внешний цикл: for (i = 0; i < n-1; i++) - гарантирует достаточное количество проходов
- Внутренний цикл: for (j = 0; j < n-i-1; j++) - исключает уже упорядоченные конечные элементы
- На каждой итерации внутреннего цикла выполняется сравнение и потенциальный обмен

**Асимптотическая оценка:**
- Верхняя граница: O(n²)
- Нижняя граница: O(n)
- Типичный случай: O(n²)

**Обоснование сложности:**
- Количество сравнений: Σ(i=0 to n-2) (n-i-1) = (n-1) + (n-2) + ... + 1 = n(n-1)/2
- Количество обменов в худшем случае: до 3 × n(n-1)/2 операций (с учетом временной переменной)
- В лучшем случае (уже отсортированный массив): только (n-1) сравнений без обменов
- Квадратичная природа возникает из-за вложенных циклов, каждый из которых зависит от n

---

## Вычислительная характеристика метода поэлементного включения

**Фундаментальные принципы:**
- Постепенное построение упорядоченной последовательности через корректную вставку элементов
- Каждый новый элемент размещается в соответствующей позиции среди уже обработанных

**Особенности вычислительного процесса:**
- Внешний цикл обрабатывает элементы с индексами от 1 до n-1
- Внутренний цикл осуществляет сдвиги и поиск позиции для вставки
- Текущий элемент сохраняется во временной переменной для последующего размещения

**Детальный анализ циклов:**
- Внешний цикл: for (i = 1; i < n; i++) - начинается со второго элемента
- Внутренний цикл: while (j >= 0 && arr[j] > key) - сдвигает элементы и ищет позицию
- Переменная key = arr[i] сохраняет вставляемый элемент

**Асимптотическая оценка:**
- Верхняя граница: O(n²)
- Нижняя граница: O(n)
- Типичный случай: O(n²)

**Обоснование сложности:**
- Количество сравнений в худшем случае: Σ(i=1 to n-1) i = n(n-1)/2
- Количество присваиваний в худшем случае: Σ(i=1 to n-1) (i + 1) = n(n+1)/2 - 1
- В лучшем случае (уже отсортированный массив): только (n-1) сравнений
- Квадратичная сложность объясняется тем, что каждый новый элемент может потребовать
  просмотра всей уже отсортированной части массива
- Эффективность сильно зависит от начальной упорядоченности данных

## Вычислительная характеристика метода рекурсивного слияния

**Фундаментальные принципы:**
- Стратегия "разделяй и властвуй" с последовательным разбиением массива на минимальные части
- Рекурсивное объединение отсортированных подмассивов в упорядоченную последовательность

**Особенности вычислительного процесса:**
- Рекурсивное деление массива пополам до достижения базового случая (1 элемент)
- Последовательное слияние отсортированных пар с формированием larger упорядоченных блоков
- Использование дополнительной памяти для временного хранения подмассивов

**Детальный анализ процедур:**
- Функция разделения: рекурсивные вызовы для левой и правой половин массива
- Процедура слияния: линейное объединение двух отсортированных массивов
- Базовый случай рекурсии: массивы размером 0 или 1 элемент (уже отсортированы)

**Асимптотическая оценка: O(n log n)**
- **Верхняя граница:** O(n log n) - гарантированная производительность для любых входных данных
- **Нижняя граница:** Ω(n log n) - минимальная сложность даже для уже отсортированных массивов
- **Типичный случай:** Θ(n log n) - стабильная производительность независимо от распределения данных

**Обоснование сложности:**
- Глубина рекурсии: ровно ⌈log₂n⌉ уровней для массива размером n
- На каждом уровне рекурсии выполняется слияние всех n элементов
- Операция слияния двух массивов размером k и m требует O(k + m) сравнений
- Суммарное количество операций: n × log₂n сравнений и перемещений

**Преимущества и ограничения:**
- Гарантированная производительность O(n log n) для всех случаев
- Требуется O(n) дополнительной памяти для операций слияния
- Стабильный алгоритм, сохраняющий порядок равных элементов
- Эффективен для больших массивов и внешней сортировки

---

## Вычислительная характеристика метода на основе дерева

**Фундаментальные принципы:**
- Использование структуры данных "двоичная куча" для эффективного извлечения экстремальных элементов
- Двухэтапный процесс: построение кучи и последовательное извлечение элементов

**Особенности вычислительного процесса:**
- Фаза построения max-heap: преобразование массива в бинарное дерево с свойством кучи
- Фаза сортировки: многократное извлечение максимального элемента и восстановление свойства кучи
- In-place обработка с использованием исходного массива для хранения кучи

**Детальный анализ процедур:**
- Построение кучи: вызов heapify для всех нелистовых узлов (от n/2-1 до 0)
- Процедура heapify: рекурсивное/итеративное восстановление свойства кучи для узла
- Извлечение элементов: n-1 операций обмена и восстановления кучи

**Асимптотическая оценка: O(n log n)**
- **Верхняя граница:** O(n log n) - худший случай для всех этапов алгоритма
- **Нижняя граница:** Ω(n log n) - минимальная сложность для любой перестановки
- **Типичный** Θ(n log n) - стабильная производительность независимо от распределения данных

**Обоснование сложности:**
- Глубина рекурсии: ровно ⌈log₂n⌉ уровней для массива размером n
- На каждом уровне рекурсии выполняется слияние всех n элементов
- Операция слияния двух массивов размером k и m требует O(k + m) сравнений
- Суммарное количество операций: n × log₂n сравнений и перемещений

## Вычислительная характеристика метода с переменным шагом


**Фундаментальные принципы:**
- Усовершенствованный подход сортировки, использующий последовательное уменьшение интервала сравнения
- Комбинированная стратегия, сочетающая преимущества вставок и группировки элементов

**Особенности вычислительного процесса:**
- Внешний цикл управляет геометрической прогрессией интервалов (n/2, n/4, ..., 1)
- Внутренние циклы выполняют модифицированную сортировку вставками для каждого интервала
- Элементы, разделенные интервалом, сравниваются и при необходимости перемещаются

**Детальный анализ циклов:**
- Внешний цикл: for (gap = n/2; gap > 0; gap /= 2) - количество итераций ≈ log₂n
- Внутренний цикл: for (i = gap; i < n; i++) - линейное сканирование элементов
- Вложенный цикл: while (j >= gap && arr[j-gap] > temp) - сдвиг элементов с шагом gap

**Асимптотическая оценка:**
- Верхняя граница: O(n²) - для базовой последовательности интервалов
- Нижняя граница: O(n log n) - для оптимальных последовательностей
- Типичный случай: O(n^(3/2)) - для последовательности Кнута
 **Обоснование сложности:**
- Количество проходов: log₂n для базовой последовательности
- На каждом проходе выполняется ≈ n операций сравнения и обмена
- Эффективность зависит от выбранной последовательности интервалов
- Оптимальные последовательности минимизируют количество инверсий


---

## Вычислительная характеристика метода с разделением

**Фундаментальные принципы:**
- Стратегия "разделяй и властвуй" с выбором опорного элемента
- Рекурсивное разбиение массива на подмассивы относительно точки разделения

**Особенности вычислительного процесса:**
- Рекурсивные вызовы обрабатывают левый и правый сегменты массива
- Процедура разделения перераспределяет элементы относительно опорного
- База рекурсии - массивы размером 0 или 1 элемент

**Детальный анализ процедур:**
- Функция разделения: линейный проход O(n) с перестановкой элементов
- Рекурсивная глубина: от log₂n до n в зависимости от баланса
- Количество операций сравнения: n log n в среднем случае

**Асимптотическая оценка:**
- Ожидаемый случай: O(n log n) - при сбалансированном разделении
- Экстремальный случай: O(n²) - при вырожденном разделении
- Лучший случай: O(n log n) - идеально сбалансированное разбиение
  **Обоснование сложности:**
- В среднем случае глубина рекурсии составляет log₂n
- На каждом уровне рекурсии выполняется O(n) операций
- В худшем случае глубина рекурсии достигает n при несбалансированном разбиении
- Выбор опорного элемента критически влияет на производительность

---

## Вычислительная характеристика метода на основе дерева

**Фундаментальные принципы:**
- Использование структуры данных "двоичная куча" для эффективного извлечения экстремальных элементов
- Двухэтапный процесс: построение кучи и последовательное извлечение элементов

**Особенности вычислительного процесса:**
- Фаза построения max-heap: преобразование массива в бинарное дерево с свойством кучи
- Фаза сортировки: многократное извлечение максимального элемента и восстановление свойства кучи
- In-place обработка с использованием исходного массива для хранения кучи

**Детальный анализ процедур:**
- Построение кучи: вызов heapify для всех нелистовых узлов (от n/2-1 до 0)
- Процедура heapify: рекурсивное/итеративное восстановление свойства кучи для узла
- Извлечение элементов: n-1 операций обмена и восстановления кучи
с
**Асимптотическая оценка: O(n log n)**
- **Верхняя граница:** O(n log n) - худший случай для всех этапов алгоритма
- **Нижняя граница:** Ω(n log n) - минимальная сложность для любой перестановки
- **Типичный** Θ(n log n) - стабильная производительность независимо от распределения данных

**Обоснование сложности:**
- Глубина рекурсии: ровно ⌈log₂n⌉ уровней для массива размером n
- На каждом уровне рекурсии выполняется слияние всех n элементов
- Операция слияния двух массивов размером k и m требует O(k + m) сравнений
- Суммарное количество операций: n × log₂n сравнений и перемещений

---



## Вычислительная характеристика дихотомического поиска

**Фундаментальные принципы:**
- Эффективный алгоритм поиска в отсортированных массивах методом деления пополам
- Последовательное сокращение области поиска в геометрической прогрессии

**Особенности вычислительного процесса:**
- Итеративное или рекурсивное деление текущего интервала поиска на две равные части
- Сравнение среднего элемента с целевым значением для определения направления поиска
- Завершение при нахождении элемента или исчерпании области поиска

**Детальный анализ процедур:**
- Инициализация: установка границ поиска [0, n-1]
- Основной цикл: while (left <= right) - продолжение пока интервал не пуст
- Вычисление середины: mid = left + (right - left) / 2 - избежание переполнения
- Сравнение: arr[mid] == target - проверка на совпадение

**Асимптотическая оценка: O(log n)**
- **Верхняя граница:** O(log n) - максимальное количество итераций для любого случая
- **Нижняя граница:** Ω(1) - элемент найден в средней позиции первой итерации
- **Типичный случай:** Θ(log n) - средняя производительность для случайных данных

**Обоснование сложности:**
- Размер области поиска уменьшается в 2 раза на каждой итерации
- Количество итераций: ⌈log₂(n + 1)⌉ в худшем случае
- На каждой итерации выполняется фиксированное количество операций (3 сравнения, 2 присваивания)
- Суммарное количество сравнений: 3 × ⌈log₂(n + 1)⌉


---
## Вычислительная характеристика метода рекурсивного слияния

**Фундаментальные принципы:**
- Стратегия "разделяй и властвуй" с последовательным разбиением массива на минимальные части
- Рекурсивное объединение отсортированных подмассивов в упорядоченную последовательность

**Особенности вычислительного процесса:**
- Рекурсивное деление массива пополам до достижения базового случая (1 элемент)
- Последовательное слияние отсортированных пар с формированием larger упорядоченных блоков
- Использование дополнительной памяти для временного хранения подмассивов

**Детальный анализ процедур:**
- Функция разделения: рекурсивные вызовы для левой и правой половин массива
- Процедура слияния: линейное объединение двух отсортированных массивов
- Базовый случай рекурсии: массивы размером 0 или 1 элемент (уже отсортированы)

**Асимптотическая оценка: O(n log n)**
- **Верхняя граница:** O(n log n) - гарантированная производительность для любых входных данных
- - **Нижняя граница:** Ω(n log n) - минимальная сложность даже для уже отсортированных массивов
- **Типичный случай:** Θ(n log n) - стабильная производительность независимо от распределения данных

**Обоснование сложности:**
- Глубина рекурсии: ровно ⌈log₂n⌉ уровней для массива размером n
- На каждом уровне рекурсии выполняется слияние всех n элементов
- Операция слияния двух массивов размером k и m требует O(k + m) сравнений
- Суммарное количество операций: n × log₂n сравнений и перемещений


## Вычислительная характеристика интерполяционного поиска

**Фундаментальные принципы:**
- Улучшенный алгоритм поиска, использующий равномерность распределения данных
- Предсказание позиции элемента на основе математической интерполяции

**Особенности вычислительного процесса:**
- Цикл поиска с вычислением предполагаемой позиции через интерполяцию
- Использование значений граничных элементов для оценки местоположения
- Геометрическое уменьшение области поиска на каждой итерации

**Детальный анализ операций:**
- Формула интерполяции: pos = low + (target-arr[low])*(high-low)/(arr[high]-arr[low])
- Количество итераций: O(log log n) при равномерном распределении
- Сравнение: arr[pos] == target - проверка найденной позиции

**Асимптотическая оценка:**
- При равномерном распределении: O(log log n) - сверхлогарифмическая скорость
- При неравномерном распределении: O(n) - вырождение до линейного поиска
- - Лучший случай: O(1) - точное попадание на первой итерации

**Обоснование сложности:**
- При равномерном распределении размер области поиска уменьшается экспоненциально
- Количество итераций пропорционально log log n благодаря точному предсказанию позиции
- В худшем случае (экспоненциальное распределение) алгоритм вырождается до O(n)
- Требует отсортированного массива и равномерного распределения для максимальной эффективности

---

## Вычислительная характеристика поиска по числам Фибоначчи

**Фундаментальные принципы:**
- Специализированный алгоритм, использующий свойства последовательности Фибоначчи
- Деление массива в пропорциях, близких к золотому сечению

**Особенности вычислительного процесса:**
- Предварительное вычисление чисел Фибоначчи, превышающих размер массива
- Циклическое уменьшение области поиска с использованием чисел Фибоначчи
- Сравнение элемента в вычисленной позиции с целевым значением

**Детальный анализ операций:**
- Инициализация: вычисление последовательности Фибоначчи - O(log n)
- Основной цикл: while (fibM > 1) - O(log n) итераций
- Вычисление позиции: i = min(offset + fibMMm2, n-1)
- Обновление чисел Фибоначчи: фиксированное количество операций на итерации

**Асимптотическая оценка: O(log n)**
- Обоснование: Количество итераций пропорционально log₂n
- Каждая итерация уменьшает область поиска примерно на 38% (отношение Фибоначчи)
- Алгоритм избегает дорогостоящих операций деления и умножения

**Сравнительные характеристики:**
- Эффективность сравнима с бинарным поиском - O(log n)
- Меньше операций сравнения, чем в бинарном поиске
- Отсутствие операций деления, только сложение и вычитание
- Особенно эффективен для больших массивов и систем с ограниченными вычислительными ресурсами
